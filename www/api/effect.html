<HTML>
<HEAD>
<TITLE>effect - ImageMagick Image Effects Methods</TITLE>
<LINK REV="made" HREF="mailto:ActivePerl@ActiveState.com">
</HEAD>

<body bgcolor="#FFFFFF" text="#000000" link="#1F00FF" alink="#FF0000"  vlink="#9900DD">

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">
<FONT SIZE=-1>NAME</FONT></A></LI>
	<LI><A HREF="#synopsis">
<FONT SIZE=-1>SYNOPSIS</FONT></A></LI>
	<LI><A HREF="#function descriptions">
<FONT SIZE=-1>FUNCTION</FONT> 
<FONT SIZE=-1>DESCRIPTIONS</FONT></A></LI>
	<UL>

		<LI><A HREF="#addnoiseimage">AddNoiseImage</A></LI>
		<LI><A HREF="#blurimage">BlurImage</A></LI>
		<LI><A HREF="#charcoalimage">CharcoalImage</A></LI>
		<LI><A HREF="#colorizeimage">ColorizeImage</A></LI>
		<LI><A HREF="#convolveimage">ConvolveImage</A></LI>
		<LI><A HREF="#despeckleimage">DespeckleImage</A></LI>
		<LI><A HREF="#edgeimage">EdgeImage</A></LI>
		<LI><A HREF="#embossimage">EmbossImage</A></LI>
		<LI><A HREF="#enhanceimage">EnhanceImage</A></LI>
		<LI><A HREF="#gaussianblurimage">GaussianBlurImage</A></LI>
		<LI><A HREF="#implodeimage">ImplodeImage</A></LI>
		<LI><A HREF="#medianfilterimage">MedianFilterImage</A></LI>
		<LI><A HREF="#morphimages">MorphImages</A></LI>
		<LI><A HREF="#motionblurimage">MotionBlurImage</A></LI>
		<LI><A HREF="#oilpaintimage">OilPaintImage</A></LI>
		<LI><A HREF="#plasmaimage">PlasmaImage</A></LI>
		<LI><A HREF="#reducenoiseimage">ReduceNoiseImage</A></LI>
		<LI><A HREF="#shadeimage">ShadeImage</A></LI>
		<LI><A HREF="#sharpenimage">SharpenImage</A></LI>
		<LI><A HREF="#solarizeimage">SolarizeImage</A></LI>
		<LI><A HREF="#spreadimage">SpreadImage</A></LI>
		<LI><A HREF="#steganoimage">SteganoImage</A></LI>
		<LI><A HREF="#stereoimage">StereoImage</A></LI>
		<LI><A HREF="#swirlimage">SwirlImage</A></LI>
		<LI><A HREF="#thresholdimage">ThresholdImage</A></LI>
		<LI><A HREF="#unsharpmaskimage">UnsharpMaskImage</A></LI>
		<LI><A HREF="#waveimage">WaveImage</A></LI>
	</UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">
<FONT SIZE=-1>NAME</FONT></A></H1>
<P>effect - ImageMagick Image Effects Methods</P>
<P>
<HR>
<H1><A NAME="synopsis">
<FONT SIZE=-1>SYNOPSIS</FONT></A></H1>
<P>Image * <STRONG>AddNoiseImage</STRONG>( Image *image, const NoiseType noise_type, ExceptionInfo *exception );</P>
<P>Image * <STRONG>BlurImage</STRONG>( Image *image, const double radius, const double sigma, ExceptionInfo *exception );</P>
<P>Image * <STRONG>CharcoalImage</STRONG>( Image *image, const double radius, const double sigma, ExceptionInfo *exception );</P>
<P>Image * <STRONG>ColorizeImage</STRONG>( Image *image, const char *opacity, const PixelPacket target, ExceptionInfo *exception );</P>
<P>Image * <STRONG>ConvolveImage</STRONG>( const Image *image, const unsigned int order, const double *kernel, ExceptionInfo *exception );</P>
<P>Image * <STRONG>DespeckleImage</STRONG>( Image *image, ExceptionInfo *exception );</P>
<P>Image * <STRONG>EdgeImage</STRONG>( Image *image, const double radius, ExceptionInfo *exception );</P>
<P>Image * <STRONG>EmbossImage</STRONG>( Image *image, const double radius, const double sigma, ExceptionInfo *exception );</P>
<P>Image * <STRONG>EnhanceImage</STRONG>( Image *image, ExceptionInfo *exception );</P>
<P>Image * <STRONG>GaussianBlurImage</STRONG>( const Image *image, const double radius, const double sigma, ExceptionInfo *exception );</P>
<P>Image * <STRONG>ImplodeImage</STRONG>( Image *image, const double amount, ExceptionInfo *exception );</P>
<P>Image * <STRONG>MedianFilterImage</STRONG>( Image *image, const double radius, ExceptionInfo *exception );</P>
<P>Image * <STRONG>MorphImages</STRONG>( Image *image, const unsigned long number_frames, ExceptionInfo *exception );</P>
<P>Image * <STRONG>MotionBlurImage</STRONG>( const Image *image, const double radius, const double sigma, const double amount, ExceptionInfo *exception );</P>
<P>Image * <STRONG>OilPaintImage</STRONG>( const Image *image, const double radius, ExceptionInfo *exception );</P>
<P>unsigned int  <STRONG>PlasmaImage</STRONG>( Image *image, const SegmentInfo *segment, int attenuate, int depth );</P>
<P>Image * <STRONG>ReduceNoiseImage</STRONG>( const Image *image, const double radius, ExceptionInfo *exception );</P>
<P>Image * <STRONG>ShadeImage</STRONG>( const Image *image, const unsigned int color_shading, double azimuth, double elevation, ExceptionInfo *exception );</P>
<P>Image * <STRONG>SharpenImage</STRONG>( const Image *image, const double radius, const double sigma, ExceptionInfo *exception );</P>
<P>void  <STRONG>SolarizeImage</STRONG>( Image *image, const double threshold );</P>
<P>Image * <STRONG>SpreadImage</STRONG>( iconst Image *image, const unsigned int amount, ExceptionInfo *exception );</P>
<P>Image * <STRONG>SteganoImage</STRONG>( Image *image, Image *watermark, ExceptionInfo *exception );</P>
<P>Image * <STRONG>StereoImage</STRONG>( const Image *image, const Image *offset_image, ExceptionInfo *exception );</P>
<P>Image * <STRONG>SwirlImage</STRONG>( const Image *image, double degrees, ExceptionInfo *exception );</P>
<P>unsigned int  <STRONG>ThresholdImage</STRONG>( Image *image, const double threshold );</P>
<P>Image * <STRONG>UnsharpMaskImage</STRONG>( const Image *image, const double radius, const double sigma, const double amount, const double threshold, ExceptionInfo *exception );</P>
<P>Image * <STRONG>WaveImage</STRONG>( const Image *image, const double amplitude, const double wave_length, ExceptionInfo *exception );</P>
<P>
<HR>
<H1><A NAME="function descriptions">
<FONT SIZE=-1>FUNCTION</FONT> 
<FONT SIZE=-1>DESCRIPTIONS</FONT></A></H1>
<P>
<H2><A NAME="addnoiseimage">AddNoiseImage</A></H2>
<P>Method AddNoiseImage creates a new image that is a copy of an existing one with noise added.  It allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The format of the AddNoiseImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *AddNoiseImage ( <A HREF="types/Image.html">Image</A> *image, const <A HREF="types/Enumerations.html#NoiseType">NoiseType</A> noise_type, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_noise_image%3A">noise_image:</A></STRONG><BR>
<DD>
Method AddNoiseImage returns a pointer to the image after the noise is minified.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG><A NAME="item_o_image%3A">image:</A></STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG><A NAME="item_o_noise_type%3A">noise_type:</A></STRONG><BR>
<DD>
The type of noise: Gaussian, multiplicative Gaussian, impulse, laplacian, or Poisson.
<P></P>
<p><dt><STRONG><A NAME="item_o_exception%3A">exception:</A></STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="blurimage">BlurImage</A></H2>
<P>Method BlurImage creates a blurred copy of the input image.  We convolve the image with a Gaussian operator of the given radius and standard deviation (sigma).</P>
<P>Each output pixel is set to a value that is the weighted average of the input pixels in an area enclosing the pixel.  The width parameter determines how large the area is.  Each pixel in the area is weighted in the average according to its distance from the center, and the standard deviation, sigma.  The actual weight is calculated according to the Gaussian distribution (also called normal distribution), which looks like a Bell Curve centered on a pixel.  The standard deviation controls how 'pointy' the curve is.  The pixels near the center of the curve (closer to the center of the area we are averaging) contribute more than the distant pixels.</P>
<P>In general, the width should be wide enough to include most of the total weight under the Gaussian for the standard deviation you choose.  the width parameter to the function specifies the radius of the Gaussian convolution mask in pixels, not counting the centre pixel, the width parameter should be chosen larger than the standard deviation, perhaps about twice as large to three times as large.  
<FONT SIZE=-1>A</FONT> width of 1 will give a (standard) 3x3 convolution mask, a width of 2 gives a 5 by 5 convolution mask.  Using non-integral widths will result in some pixels being considered 'partial' pixels, in which case their weight will be reduced proportionally.</P>
<P>Pixels for which the convolution mask does not completely fit on the image (e.g.  pixels without a full set of neighbours) are averaged with those neighbours they do have.  Thus pixels at the edge of images are typically less blur.</P>
<P>Since a 2d Gaussian is seperable, we perform the Gaussian blur by convolving with two 1d Gaussians, first in the x, then in the y direction.  For an n by n image and Gaussian width w this requires 2wn^2 multiplications, while convolving with a 2d Gaussian requres w^2n^2 mults.</P>
<P>We blur the image into a copy, and the original is left untouched.  We must process the image in two passes, in each pass we change the pixel based on its neighbors, but we need the pixel's original value for the next pixel's calculation.  For the first pass we could use the original image but that's no good for the second pass, and it would imply that the original image have to stay around in ram.  Instead we use a small (size=width) buffer to store the pixels we have overwritten.</P>
<P>This method was contributed by <A HREF="mailto:runger@cs.mcgill.ca.">runger@cs.mcgill.ca.</A></P>
<P>The format of the BlurImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *BlurImage ( <A HREF="types/Image.html">Image</A> *image, const double radius, const double sigma, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_blur_image%3A">blur_image:</A></STRONG><BR>
<DD>
Method BlurImage returns a pointer to the image after it is blur.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG><A NAME="item_o_radius%3A">radius:</A></STRONG><BR>
<DD>
The radius of the Gaussian, in pixels, not counting the center pixel.
<P></P>
<p><dt><STRONG><A NAME="item_o_sigma%3A">sigma:</A></STRONG><BR>
<DD>
The standard deviation of the Gaussian, in pixels.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="charcoalimage">CharcoalImage</A></H2>
<P>Method CharcoalImage creates a new image that is a copy of an existing one with the edge highlighted.  It allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The format of the CharcoalImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *CharcoalImage ( <A HREF="types/Image.html">Image</A> *image, const double radius, const double sigma, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_charcoal_image%3A">charcoal_image:</A></STRONG><BR>
<DD>
Method CharcoalImage returns a pointer to the image after it is embossed.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P>
<p><dt><STRONG>radius:</STRONG><BR>
<DD>
the radius of the pixel neighborhood.
<P></P>
<p><dt><STRONG>sigma:</STRONG><BR>
<DD>
The standard deviation of the Gaussian, in pixels.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="colorizeimage">ColorizeImage</A></H2>
<P>Method ColorizeImage creates a new image that is a copy of an existing one with the image pixels colorized.  The colorization is controlled with the pen color and the opacity levels.</P>
<P>The format of the ColorizeImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *ColorizeImage ( <A HREF="types/Image.html">Image</A> *image, const char *opacity, const <A HREF="types/PixelPacket.html">PixelPacket</A> target, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG><A NAME="item_o_opacity%3A">opacity:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> character string indicating the level of opacity as a percentage (0-100).
<P></P>
<p><dt><STRONG><A NAME="item_o_target%3A">target:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> color value.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="convolveimage">ConvolveImage</A></H2>
<P>Method ConvolveImage applies a general image convolution kernel to an image returns the results.  ConvolveImage allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The format of the ConvolveImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *ConvolveImage ( const <A HREF="types/Image.html">Image</A> *image, const unsigned int order, const double *kernel, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_convolve_image%3A">convolve_image:</A></STRONG><BR>
<DD>
Method ConvolveImage returns a pointer to the image after it is convolved.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG><A NAME="item_o_order%3A">order:</A></STRONG><BR>
<DD>
The number of columns and rows in the filter kernel.
<P></P>
<p><dt><STRONG><A NAME="item_o_kernel%3A">kernel:</A></STRONG><BR>
<DD>
An array of double representing the convolution kernel.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="despeckleimage">DespeckleImage</A></H2>
<P>Method DespeckleImage creates a new image that is a copy of an existing one with the speckle noise minified.  It uses the eight hull algorithm described in Applied Optics, Vol.  24, No.  10, 15 May 1985, ``Geometric filter for Speckle Reduction'', by Thomas 
<FONT SIZE=-1>R</FONT> Crimmins.  Each pixel in the image is replaced by one of its eight of its surrounding pixels using a polarity and negative hull function.  DespeckleImage allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The format of the DespeckleImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *DespeckleImage ( <A HREF="types/Image.html">Image</A> *image, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_despeckle_image%3A">despeckle_image:</A></STRONG><BR>
<DD>
Method DespeckleImage returns a pointer to the image after it is despeckled.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="edgeimage">EdgeImage</A></H2>
<P>Method EdgeImage creates a new image that is a copy of an existing one with the edges enhanced.  It allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The format of the EdgeImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *EdgeImage ( <A HREF="types/Image.html">Image</A> *image, const double radius, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_edge_image%3A">edge_image:</A></STRONG><BR>
<DD>
Method EdgeImage returns a pointer to the image after it is edge.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the address of a structure of type Image; returned from ReadImage.
<P></P>
<p><dt><STRONG>radius:</STRONG><BR>
<DD>
the radius of the pixel neighborhood.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="embossimage">EmbossImage</A></H2>
<P>Method EmbossImage creates a new image that is a copy of an existing one with the edge highlighted.  It allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The format of the EmbossImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *EmbossImage ( <A HREF="types/Image.html">Image</A> *image, const double radius, const double sigma, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_emboss_image%3A">emboss_image:</A></STRONG><BR>
<DD>
Method EmbossImage returns a pointer to the image after it is embossed.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG>radius:</STRONG><BR>
<DD>
the radius of the pixel neighborhood.
<P></P>
<p><dt><STRONG>sigma:</STRONG><BR>
<DD>
The standard deviation of the Gaussian, in pixels.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="enhanceimage">EnhanceImage</A></H2>
<P>Method EnhanceImage creates a new image that is a copy of an existing one with the noise minified.  It allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>EnhanceImage does a weighted average of pixels in a 5x5 cell around each target pixel.  Only pixels in the 5x5 cell that are within a 
<FONT SIZE=-1>RGB</FONT> distance threshold of the target pixel are averaged.</P>
<P>Weights assume that the importance of neighboring pixels is negately proportional to the square of their distance from the target pixel.</P>
<P>The scan only processes pixels that have a full set of neighbors.  Pixels in the top, bottom, left, and right pairs of rows and columns are omitted from the scan.</P>
<P>The format of the EnhanceImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *EnhanceImage ( <A HREF="types/Image.html">Image</A> *image, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_enhance_image%3A">enhance_image:</A></STRONG><BR>
<DD>
Method EnhanceImage returns a pointer to the image after it is enhanced.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="gaussianblurimage">GaussianBlurImage</A></H2>
<P>Method GaussianBlurImage creates a new image that is a copy of an existing one with the pixels blur.  It allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The format of the BlurImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *GaussianBlurImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, const double sigma, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>blur_image:</STRONG><BR>
<DD>
Method GaussianBlurImage returns a pointer to the image after it is blur.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>radius:</STRONG><BR>
<DD>
the radius of the Gaussian, in pixels, not counting the center pixel.
<P></P>
<p><dt><STRONG>sigma:</STRONG><BR>
<DD>
the standard deviation of the Gaussian, in pixels.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="implodeimage">ImplodeImage</A></H2>
<P>Method ImplodeImage creates a new image that is a copy of an existing one with the image pixels ``implode'' by the specified percentage.  It allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The format of the ImplodeImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *ImplodeImage ( <A HREF="types/Image.html">Image</A> *image, const double amount, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_implode_image%3A">implode_image:</A></STRONG><BR>
<DD>
Method ImplodeImage returns a pointer to the image after it is implode.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG><A NAME="item_o_amount%3A">amount:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> double value that defines the extent of the implosion.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="medianfilterimage">MedianFilterImage</A></H2>
<P>Method MedianFilterImage creates a new image that is a copy of an existing one with each pixel component replaced with the median color in a pixel neighborhood.</P>
<P>The format of the MedianFilterImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *MedianFilterImage ( <A HREF="types/Image.html">Image</A> *image, const double radius, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_median_image%3A">median_image:</A></STRONG><BR>
<DD>
Method MedianFilterImage returns a pointer to the image after it is `filtered'. 
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the address of a structure of type Image; returned from ReadImage.
<P></P>
<p><dt><STRONG>radius:</STRONG><BR>
<DD>
the radius of the pixel neighborhood.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="morphimages">MorphImages</A></H2>
<P>Method MorphImages morphs a sequence of images.  Both the next pixels and size are linearly interpolated to give the appearance of a meta-morphosis from one next to the next.</P>
<P>The format of the MorphImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *MorphImages ( <A HREF="types/Image.html">Image</A> *image, const unsigned long number_frames, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_morph_images%3A">morph_images:</A></STRONG><BR>
<DD>
Method MorphImages returns an next sequence that has linearly interpolated pixels and size between two input image.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P>
<p><dt><STRONG><A NAME="item_o_number_frames%3A">number_frames:</A></STRONG><BR>
<DD>
This unsigned integer reflects the number of in-between image to generate.  The more in-between frames, the smoother the morph.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="motionblurimage">MotionBlurImage</A></H2>
<P>Method MotionBlurImage creates a new image that has a ``motion blur'' effect applied to it.</P>
<P>Andrew Protano contributed this effect.</P>
<P>The format of the MotionBlurImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *MotionBlurImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, const double sigma, const double amount, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>blur_image:</STRONG><BR>
<DD>
Method MotionBlurImage returns a pointer to the image after it is blur.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>radius:</STRONG><BR>
<DD>
The radius of the Gaussian, in pixels, not counting the center pixel.
<P></P>
<p><dt><STRONG>sigma:</STRONG><BR>
<DD>
The standard deviation of the Gaussian, in pixels.
<P></P>
<p><dt><STRONG><A NAME="item_o_angle%3A">angle:</A></STRONG><BR>
<DD>
Apply the effect along this angle.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="oilpaintimage">OilPaintImage</A></H2>
<P>Method OilPaintImage creates a new image that is a copy of an existing one with each pixel component replaced with the color of greatest frequency in a circular neighborhood.</P>
<P>The format of the OilPaintImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *OilPaintImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_paint_image%3A">paint_image:</A></STRONG><BR>
<DD>
Method OilPaintImage returns a pointer to the image after it is `painted'. 
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG>radius:</STRONG><BR>
<DD>
The radius of the circular neighborhood.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="plasmaimage">PlasmaImage</A></H2>
<P>Method PlasmaImage initializes an image with plasma fractal values.  The image must be initialized with a base color and the random number generator seeded before this method is called.</P>
<P>The format of the PlasmaImage method is:</P>
<blockquote>unsigned int PlasmaImage ( <A HREF="types/Image.html">Image</A> *image, const SegmentInfo *segment, int attenuate, int depth ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_status%3A">status:</A></STRONG><BR>
<DD>
Method PlasmaImage returns True when the fractal process is complete.  Otherwise False is returned.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG><A NAME="item_o_segment%3A">segment:</A></STRONG><BR>
<DD>
specifies a structure of type SegmentInfo that defines the boundaries of the area where the plasma fractals are applied.
<P></P>
<p><dt><STRONG><A NAME="item_o_attenuate%3A">attenuate:</A></STRONG><BR>
<DD>
specifies the plasma attenuation factor.
<P></P>
<p><dt><STRONG><A NAME="item_o_depth%3A">depth:</A></STRONG><BR>
<DD>
this integer values define the plasma recursion depth.
<P></P></DL></DL>
<P>
<H2><A NAME="reducenoiseimage">ReduceNoiseImage</A></H2>
<P>Method ReduceNoiseImage creates a new image that is a copy of an existing one with the noise minified with a noise peak elimination filter.  It allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The principal function of noise peak elimination filter is to smooth the objects within an image without losing edge information and without creating undesired structures.  The central idea of the algorithm is to replace a pixel with its next neighbor in value within a window, if this pixel has been found to be noise.  
<FONT SIZE=-1>A</FONT> pixel is defined as noise if and only if this pixel is a maximum or minimum within the window.</P>
<P>The format of the ReduceNoiseImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *ReduceNoiseImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>noise_image:</STRONG><BR>
<DD>
Method ReduceNoiseImage returns a pointer to the image after the noise is minified.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the address of a structure of type Image; returned from ReadImage.
<P></P>
<p><dt><STRONG>radius:</STRONG><BR>
<DD>
the radius of the pixel neighborhood.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="shadeimage">ShadeImage</A></H2>
<P>Method ShadeImage creates a new image that is a copy of an existing one with the image pixels shaded using a distance light source.  It allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The format of the ShadeImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *ShadeImage ( const <A HREF="types/Image.html">Image</A> *image, const unsigned int color_shading, double azimuth, double elevation, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_shade_image%3A">shade_image:</A></STRONG><BR>
<DD>
Method ShadeImage returns a pointer to the image after it is shaded.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG><A NAME="item_o_color_shading%3A">color_shading:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> value other than zero shades the red, green, and blue components of the image.
<P></P>
<p><dt><STRONG><A NAME="item_o_azimuth%2C_elevation%3A">azimuth, elevation:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> double value that indicates the light source direction.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="sharpenimage">SharpenImage</A></H2>
<P>Method SharpenImage creates a new image that is sharpened version of the original image using a Laplacian convolution kernel.</P>
<P>The format of the SharpenImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *SharpenImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, const double sigma, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_sharp_image%3A">sharp_image:</A></STRONG><BR>
<DD>
Method SharpenImage returns a pointer to the image after it is sharp.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>radius:</STRONG><BR>
<DD>
The radius of the Gaussian, in pixels, not counting the center pixel.
<P></P>
<p><dt><STRONG>sigma:</STRONG><BR>
<DD>
The standard deviation of the Laplacian, in pixels.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="solarizeimage">SolarizeImage</A></H2>
<P>Method SolarizeImage produces a 'solarization' effect seen when exposing a photographic film to light during the development process.</P>
<P>The format of the SolarizeImage method is:</P>
<blockquote>void SolarizeImage ( <A HREF="types/Image.html">Image</A> *image, const double threshold ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG><A NAME="item_o_threshold%3A">threshold:</A></STRONG><BR>
<DD>
An double value that defines the extent of the solarization.
<P></P></DL></DL>
<P>
<H2><A NAME="spreadimage">SpreadImage</A></H2>
<P>Method SpreadImage creates a new image that is a copy of an existing one with the image pixels randomly displaced.  It allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The format of the SpreadImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *SpreadImage ( iconst <A HREF="types/Image.html">Image</A> *image, const unsigned int amount, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_spread_image%3A">spread_image:</A></STRONG><BR>
<DD>
Method SpreadImage returns a pointer to the image after it is spread.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG>amount:</STRONG><BR>
<DD>
An unsigned value constraining the ``vicinity'' for choosing a random pixel to swap.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="steganoimage">SteganoImage</A></H2>
<P>Method SteganoImage hides a digital watermark within the image.</P>
<P>The format of the SteganoImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *SteganoImage ( <A HREF="types/Image.html">Image</A> *image, <A HREF="types/Image.html">Image</A> *watermark, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_stegano_image%3A">stegano_image:</A></STRONG><BR>
<DD>
Method SteganoImage returns a pointer to the steganographic image with the watermark hidden.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P>
<p><dt><STRONG><A NAME="item_o_watermark%3A">watermark:</A></STRONG><BR>
<DD>
The image.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="stereoimage">StereoImage</A></H2>
<P>Method StereoImage combines two images and produces a single image that is the composite of a left and right image of a stereo pair.  The left image is converted to gray scale and written to the red channel of the stereo image.  The right image is converted to gray scale and written to the blue channel of the stereo image.  View the composite image with red-blue glasses to create a stereo effect.</P>
<P>The format of the StereoImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *StereoImage ( const <A HREF="types/Image.html">Image</A> *image, const <A HREF="types/Image.html">Image</A> *offset_image, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_stereo_image%3A">stereo_image:</A></STRONG><BR>
<DD>
Method StereoImage returns a pointer to the stereo image.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
The image.
<P></P>
<p><dt><STRONG><A NAME="item_o_offset_image%3A">offset_image:</A></STRONG><BR>
<DD>
The image.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="swirlimage">SwirlImage</A></H2>
<P>Method SwirlImage creates a new image that is a copy of an existing one with the image pixels ``swirl'' at a specified angle.  It allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The format of the SwirlImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *SwirlImage ( const <A HREF="types/Image.html">Image</A> *image, double degrees, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_swirl_image%3A">swirl_image:</A></STRONG><BR>
<DD>
Method SwirlImage returns a pointer to the image after it is swirl.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG><A NAME="item_o_degrees%3A">degrees:</A></STRONG><BR>
<DD>
An double value that defines the tightness of the swirling.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="thresholdimage">ThresholdImage</A></H2>
<P>Method ThresholdImage thresholds the reference image.</P>
<P>The format of the ThresholdImage method is:</P>
<blockquote>unsigned int ThresholdImage ( <A HREF="types/Image.html">Image</A> *image, const double threshold ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG>threshold:</STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> double indicating the threshold value.
<P></P></DL></DL>
<P>
<H2><A NAME="unsharpmaskimage">UnsharpMaskImage</A></H2>
<P>Method UnsharpMaskImage creates a new image that is sharpened version of the original image using the unsharp mask algorithm.</P>
<P>The format of the UnsharpMaskImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *UnsharpMaskImage ( const <A HREF="types/Image.html">Image</A> *image, const double radius, const double sigma, const double amount, const double threshold, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_unsharp_image%3A">unsharp_image:</A></STRONG><BR>
<DD>
Method UnsharpMaskImage returns a pointer to the image after it is sharpened.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>radius:</STRONG><BR>
<DD>
The radius of the Gaussian, in pixels, not counting the center pixel.
<P></P>
<p><dt><STRONG>sigma:</STRONG><BR>
<DD>
The standard deviation of the Gaussian, in pixels.
<P></P>
<p><dt><STRONG>amount:</STRONG><BR>
<DD>
The percentage of the difference between the original and the blur image that is added back into the original.
<P></P>
<p><dt><STRONG>threshold:</STRONG><BR>
<DD>
The threshold in pixels needed to apply the diffence amount.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
<P></P></DL></DL>
<P>
<H2><A NAME="waveimage">WaveImage</A></H2>
<P>Method WaveImage creates a new image that is a copy of an existing one with the image pixels altered along a sine wave.  It allocates the memory necessary for the new Image structure and returns a pointer to the new image.</P>
<P>The format of the WaveImage method is:</P>
<blockquote><A HREF="types/Image.html">Image</A> *WaveImage ( const <A HREF="types/Image.html">Image</A> *image, const double amplitude, const double wave_length, <A HREF="types/ExceptionInfo.html">ExceptionInfo</A> *exception ); </blockquote><P>
<FONT SIZE=-1>A</FONT> description of each parameter follows:</P>
<DL><DL>
<p><dt><STRONG><A NAME="item_o_wave_image%3A">wave_image:</A></STRONG><BR>
<DD>
Method WaveImage returns a pointer to the image after it is waved.  
<FONT SIZE=-1>A</FONT> null image is returned if there is a memory shortage.
<P></P>
<p><dt><STRONG>image:</STRONG><BR>
<DD>
the image.
<P></P>
<p><dt><STRONG><A NAME="item_o_amplitude%2C_frequency%3A">amplitude, frequency:</A></STRONG><BR>
<DD>

<FONT SIZE=-1>A</FONT> double value that indicates the amplitude and wave_length of the sine wave.
<P></P>
<p><dt><STRONG>exception:</STRONG><BR>
<DD>
Return any errors or warnings in this structure.
</DL></DL>

</BODY>

</HTML>
